"""ISS topic filter — reject files clearly NOT about the International Space Station.

This module provides regex-based rules to classify whether a NASA video
file is ISS-related, based on its IA identifier and filename(s).

Design philosophy:
  • Only REJECT items with strong non-ISS signals (Apollo, Artemis, Hubble, …).
  • Ambiguous items default to KEEP — better to download an extra video than
    miss real ISS content.
  • ISS indicators override reject signals when the identifier itself is
    clearly ISS (e.g. ``iss063m…`` containing "artemis" in a filename).
  • ISS crew surnames are loaded from ``iss_crew_names.json`` (generated by
    ``build_iss_crew_names.py`` from the ISSiRT crew arrivals/departures data).
"""

from __future__ import annotations

import json
import re
import unicodedata
from pathlib import Path

# ─────────────────────────────────────────────────────────────────────
# Filename-aware word boundaries
# ─────────────────────────────────────────────────────────────────────
# Python ``\b`` treats underscores as word characters, so ``\bexpedition\b``
# fails to match ``Expedition_55``.  We use custom boundaries instead.
_WB = r"(?:^|(?<=[\s\-_./]))"           # word-begin
_WE = r"(?:$|(?=[\s\-_./\d]))"          # word-end (also breaks before digit)


def _wp(word: str) -> str:
    """Wrap *word* in filename-aware word boundaries."""
    return _WB + word + _WE


# ─────────────────────────────────────────────────────────────────────
# Load ISS crew names from JSON
# ─────────────────────────────────────────────────────────────────────
_CREW_NAMES_PATH = Path(__file__).with_name("iss_crew_names.json")


def _strip_accents(s: str) -> str:
    """Remove diacritics: 'auñón-chancellor' → 'aunon-chancellor'."""
    nfkd = unicodedata.normalize("NFKD", s)
    return "".join(c for c in nfkd if not unicodedata.combining(c))


def _load_crew_patterns() -> list[str]:
    """Build regex patterns from the crew-names JSON file."""
    patterns: list[str] = []
    with open(_CREW_NAMES_PATH, encoding="utf-8") as f:
        data = json.load(f)

    # Standalone surnames (long enough / distinctive enough)
    for name in data.get("surnames", []):
        # For hyphenated names, allow underscore/hyphen/space between parts
        ascii_name = _strip_accents(name)
        if "-" in ascii_name:
            # e.g. 'caldwell-dyson' → 'caldwell[\s\-_./]*dyson'
            parts = ascii_name.split("-")
            pat = r"[\s\-_./]*".join(re.escape(p) for p in parts)
            patterns.append(rf"{_WB}{pat}")
        elif "'" in ascii_name:
            # e.g. "o'hara" → 'o.?hara'
            pat = ascii_name.replace("'", ".?")
            patterns.append(rf"{_WB}{re.escape(pat)}")
        else:
            patterns.append(rf"{_WB}{re.escape(ascii_name)}")

    # First+last combos for ambiguous/short surnames
    for surname, firsts in data.get("first_last_combos", {}).items():
        ascii_surname = _strip_accents(surname)
        for first in firsts:
            ascii_first = _strip_accents(first.lower())
            patterns.append(
                rf"{_WB}{re.escape(ascii_first)}[\s\-_.]*{re.escape(ascii_surname)}"
            )

    # Special case: Vande Hei (surname stored as just "Hei")
    # The first+last combo gives us "mark[\s\-_.]*hei" but filenames use
    # "Vande_Hei" or "VandeHei", so add an explicit pattern.
    patterns.append(r"vande[\s\-_./]*hei")

    return patterns


_CREW_PATTERNS: list[str] = _load_crew_patterns()


# ─────────────────────────────────────────────────────────────────────
# REJECT patterns — programs/topics that are DEFINITELY NOT space station
# ─────────────────────────────────────────────────────────────────────
_REJECT_PROGRAMS: list[str] = [
    rf"{_WB}apollo",              # Apollo (with or without number suffix)
    _wp("artemis"),
    _wp("orion"),
    r"james[\s\-_./]*webb",
    _wp("jwst"),
    rf"{_WB}osiris",
    _wp("hubble"),
    _wp("lunar"),
    _wp("sls"),
    _wp("moon"),
    _wp("mars"),
    _wp("perseverance"),
    _wp("curiosity"),
    _wp("ingenuity"),
]

_REJECT_NONNASA: list[str] = [
    _wp("coitx"),
    _wp("wtvnj"),
    r"john[\s\-_./]*wayne",
]

_REJECT_GENERAL_NASA: list[str] = [
    r"nasa[\s\-_./]*administrator[\s\-_./]*interview",
    r"nasa[\s\-_./]*administrator[\s\-_./]*talks",
    r"nasa[\s\-_./]*knowledge",
    r"astronaut[\s\-_./]*biographical",
    r"astronaut[\s\-_./]*graduation",
    r"nasa[\s\-_./]*60th[\s\-_./]*anniversary",
    r"launchamerica[\s\-_./]*opening",
    r"highschoolaerospacescholars",
    r"deputy[\s\-_./]*administrator.*interview.*jfk",
    r"4[\s\-_./]*h[\s\-_./]*and[\s\-_./]*nasa",
    r"nasa[\s\-_./]*revealing.*asteroid",
    r"nasaastronautbiographical",
    r"houston[\s\-_./]*we[\s\-_./]*have[\s\-_./]*a[\s\-_./]*podcast",
]

# ─────────────────────────────────────────────────────────────────────
# ISS INDICATORS — strong positive signals (structural / topical)
# ─────────────────────────────────────────────────────────────────────
_ISS_STRUCTURAL: list[str] = [
    # Expedition (various forms)
    rf"{_WB}expedition",          # Expedition_55, Expedition55
    rf"{_WB}exp[\-_.]?\d",        # Exp-54, Exp_61, Exp57
    rf"{_WB}e\d{{2}}[\-_]",       # E57-58, E55_Inflight
    rf"{_WB}e\d{{2}}[a-z]",       # E43_1YearCrew

    # ISS identifiers
    rf"{_WB}iss(?:$|[\s\-_./\d])",
    r"iss\d{3}",                  # iss063m… (IA identifier prefix)

    # Station
    r"space[\s\-_./]*station",
    r"station[\s\-_./]*commander",
    r"flight[\s\-_./]*engineer",

    # Inflight
    rf"{_WB}inflight",
    r"in[\-_\s]flight",

    # EVA / Spacewalk
    rf"{_WB}spacewalk",
    r"u\.s\.spacewalk",
    r"eva[\-_\s]\d",

    # SpaceX Crew missions (all ISS-bound)
    rf"{_WB}crew[\-_]?\d",        # Crew-4, Crew1, Crew-12

    # SpaceX Demo-2 / Boeing OFT-2
    rf"{_WB}dm[\-_]?\d",
    rf"{_WB}demo[\-_]?\d",
    rf"{_WB}oft[\-_]?\d",

    # Programs
    r"commercial[\s\-_./]*crew",
    rf"{_WB}ccp(?:$|[\s\-_./])",
    rf"{_WB}ariss",               # Amateur Radio on ISS
    rf"{_WB}usos",                # US Orbital Segment

    # Launch/transport vehicles (ISS context)
    rf"{_WB}soyuz",
    rf"{_WB}gctc",
    rf"{_WB}starliner",
    r"crew[\s\-_./]*flight[\s\-_./]*test",
    r"state[\s\-_./]*commission",

    # ISS crew events
    rf"{_WB}splashdown",
    r"post[\s\-_./]*docking",
    r"post[\s\-_./]*landing",
    r"post[\s\-_./]*flight",
    r"hatch[\s\-_./]*closure",

    # Context signals
    rf"{_WB}pao(?:$|[\s\-_./])",  # Public Affairs Office events
    r"ham[\s\-_./]*radio",
    rf"{_WB}spacex(?:$|[\s\-_./])",
    rf"{_WB}hunch",               # ISS education programme
]

# Combined: structural patterns + crew-name patterns
_ISS_INDICATORS: list[str] = _ISS_STRUCTURAL + _CREW_PATTERNS

# ─────────────────────────────────────────────────────────────────────
# Pre-ISS Shuttle missions (STS < 88) and Hubble servicing missions
# ─────────────────────────────────────────────────────────────────────
_HUBBLE_STS = {103, 109, 125}


def _has_pattern(text: str, patterns: list[str]) -> str | None:
    """Return the first matching pattern (or *None*).

    Text is lowered and accent-stripped so patterns match filenames that may
    or may not preserve diacritics.
    """
    lower = _strip_accents(text.lower())
    for pat in patterns:
        if re.search(pat, lower):
            return pat
    return None


def _is_non_iss_sts(text: str) -> str | None:
    m = re.search(r"sts[\-_]?(\d+)", text.lower())
    if m:
        num = int(m.group(1))
        if num < 88:
            return f"STS-{num} (pre-ISS era)"
        if num in _HUBBLE_STS:
            return f"STS-{num} (Hubble servicing)"
    return None


# ─────────────────────────────────────────────────────────────────────
# Public API
# ─────────────────────────────────────────────────────────────────────

def classify_iss_relevance(
    identifier: str,
    filenames: list[str] | None = None,
) -> tuple[str, str]:
    """Decide whether *identifier* (+ optional *filenames*) is ISS-related.

    Returns ``(decision, reason)`` where *decision* is one of:

    * ``"keep"``      — confident ISS content
    * ``"reject"``    — confident non-ISS content
    * ``"ambiguous"`` — no strong signal either way (treated as keep)

    The caller can use *decision* to override ``likely_relevant`` in the
    classified-candidates JSONL.
    """
    all_text = identifier
    if filenames:
        all_text += " " + " ".join(filenames)

    iss_match = _has_pattern(all_text, _ISS_INDICATORS)
    reject_prog = _has_pattern(all_text, _REJECT_PROGRAMS)
    reject_junk = _has_pattern(all_text, _REJECT_NONNASA)
    reject_general = _has_pattern(all_text, _REJECT_GENERAL_NASA)
    sts_reject = _is_non_iss_sts(all_text)

    # Non-NASA junk — always reject
    if reject_junk:
        return "reject", f"non-NASA content ({reject_junk})"

    # Non-ISS programme mentioned together with an ISS indicator:
    # trust the identifier prefix to decide who wins.
    if reject_prog and iss_match:
        ident_is_iss = _has_pattern(identifier, [
            rf"{_WB}expedition",
            rf"{_WB}exp[\-_.]?\d",
            r"iss\d{{3}}",
        ])
        if ident_is_iss:
            return "keep", (
                f"ISS context ({ident_is_iss}) despite mention of {reject_prog}"
            )
        return "reject", (
            f"non-ISS program ({reject_prog}); "
            f"ISS indicator ({iss_match}) is secondary"
        )

    if reject_prog:
        return "reject", f"non-ISS program ({reject_prog})"

    if reject_general and not iss_match:
        return "reject", f"general NASA ({reject_general})"

    if sts_reject and not iss_match:
        return "reject", f"non-ISS shuttle ({sts_reject})"

    if iss_match:
        return "keep", f"ISS indicator ({iss_match})"

    return "ambiguous", "no clear ISS or non-ISS signal"


def is_iss_reject(
    identifier: str,
    filenames: list[str] | None = None,
) -> bool:
    """Return ``True`` if the item should be rejected as non-ISS.

    Convenience wrapper: ambiguous items are treated as *not* rejected.
    """
    decision, _reason = classify_iss_relevance(identifier, filenames)
    return decision == "reject"
